{
  "questions": [
    {
      "question": "What does the SOLID principle stand for?",
      "answer": [
        "Single responsibility principle - a class should have only a single responsibility",
        "Open/Closed principle - a class should be open for extension, but closed for modification",
        "Liskov substitution principle - Objects in a program should be replaceable with instances of their subtypes. Without altering the correctness of that program. Design by contract",
        "Interface segregation principle - Many client specific interfaces are better than one general purpose interface",
        "Dependancy inversion principle - Should depend upon abstractions. Do not depend on concretions"
      ]
    },
    {
      "question": "How to maintain orthogonality",
      "answer": [
        "Design independent, well-defined components",
        "Keep your code decoupled",
        "Avoid global data",
        "Refactor similar functions"
      ]
    },
    {
      "question": "What is the principle of least knowledge",
      "answer": ["only depend on your immediate friends"]
    },
    {
      "question": "What is a design pattern?",
      "answer": ["A pattern is a solution to a problem in a context"]
    },
    {
      "question": "Le Blanc's law",
      "answer": ["Later equals never"]
    },
    {
      "question": "Rules of simple code",
      "answer": [
        "Runs all the tests",
        "Contains no duplication",
        "Expresses all the design ideas that are in the system",
        "Minimise the number of entities such as classes, methods, functions and the like"
      ]
    },
    {
      "question": "What makes the program appear simple",
      "answer": ["It's not the language that makes programs appear simple. It is the programmer that makes the language appear simple!"]
    },
    {
      "question": "Good naming does not require?",
      "answer": ["If a name requires a comment, then the name does not reveal its intent"]
    },
    {
      "question": "Length of a name should correspond to?",
      "answer": ["The size of its scope"]
    },
    {
      "question": "Single responsibility principle",
      "answer": ["A class should only have one reason to change"]
    },
    {
      "question": "Cohesion",
      "answer": ["A cohesive class should have most of its methods use all instance variables in a class"]
    },
    {
      "question": "Clean tests follow the F.I.R.S.T principle, what is the F.I.R.S.T principle",
      "answer": [
        "Fast - tests should be fast. When tests run slow, you won't want to run them frequently. this can cause code rot through lazyness.",
        "Independent - tests should not depend on each other, then the first one to fail causes a cascade of downstream failures, making diagnosis difficult and hiding down stream defects.",
        "Repeatable - tests should be repeatable in any environment. Don't give your self an excuse of why they fail, this will cause complacency in your code and of course rot.",
        "Self-Validating - the tests should have a boolean output. Pass and failure should never be subjective.",
        "Timely - the tests need to be written in a timely fashion. Test should be written 'just before' production code. By doing this you refactor and create more readable code."
      ]
    },
    {
      "question": "Asking someone for knowledge is like a cup",
      "answer": [
        "continuously empty your cup. Basically don't go on about what you know if you want to know what they know",
        "also known as a white belt mentality. Ask about what your are being taught."
      ]
    },
    {
      "question": "good things not sure on how to question it but read :)",
      "answer": [
        "Avoid defending your current level of knowledge - the apprentice should strive to become more teachable",
        "pointing out mistakes or what you think are mistakes is a good way of learning",
        "reflect on failure"
      ]
    },
    {
      "question": "Three things a good bug report should convey",
      "answer": [
        "1. How to reproduce the bug, as precisely as possible, and how often this will make a bug appear.",
        "2. What should have happened, at least in your opinion",
        "3. What actually happened, or at least as much information as you have recorded"
      ]
    },
    {
      "question": "Big O notation for Array Index",
      "answer": ["O(1) - Constant"]
    },
    {
      "question": "Big O notation for Binary search",
      "answer": ["O(log n) - Logarithmic"]
    },
    {
      "question": "Big O notation for String comparison",
      "answer": ["O(n) - Linear"]
    },
    {
      "question": "Big O notation for quick sort",
      "answer": ["O(n log n) - n log n"]
    },
    {
      "question": "Big O notation for simple sorting methods",
      "answer": ["O(n^2) - Quadratic"]
    },
    {
      "question": "Big O notation for matrix multiplication",
      "answer": ["O(n^3) - Cubic"]
    },
    {
      "question": "Big O notation for set partitioning",
      "answer": ["O(2^n) - exponential"]
    },
    {
      "question": "Testing",
      "answer": [
        "Test code at its boundaries",
        "Test pre and post conditions",
        "Test incrementally",
        "Test simple parts first",
        "Know what output to expect",
        "Measure test coverage",
        "Automate regression testing",
        "Create self-contained tests"
      ]
    },
    {
      "question": "What should you do when debugging",
      "answer": [
        "Look for familiar patterns",
        "Examine the most recent change",
        "Debug now not latter",
        "Read before typing",
        "Explain your code to someone else",
        "Make the bug reproducible",
        "Divide and conquer, your code!",
        "Study numerology of failures",
        "Display output to localize your search",
        "draw a picture!",
        "use tools",
        "keep records"
      ]
    },
    {
      "question": "Ensuring code is Portable (all about Portability)",
      "answer": [
        "Stick to the standard",
        "Try several compilers",
        "Hide system dependencies behind interfaces",
        "Don't assume ASCII or UTF-8"
      ]
    },
    {
      "question": "Measuring performance",
      "answer": [
        "Automate timing measurements",
        "Use a profiler",
        "Concentrate on the hot spots",
        "Draw a picture",
        "Don't optimise what does not matter",
        "Cache frequently-used values",
        "Buffer input and output",
        "Pre compute results",
        "Use approx values"
      ]
    },
    {
      "question": "Transactions should be ACID what does this mean?",
      "answer": [
        "Atomic - Atomicity ensures that all the operations happen in a transaction or none",
        "Consistent - Once a transaction ends (successfully or not), the system is left in a state consistent with the business that it models. The data shouldn't be corrupted with respect to reality",
        "Isolated - Transactions should allow multiple users to work with the data, without each user's work getting tangled up with the others. (Synchronized/Locking)",
        "Durable - Once a transaction has been completed, the results of the transaction should be made permanent so that they'll survive any sort of system crash"
      ]
    },
    {
      "question": "What is a dirty read?",
      "answer": ["Occurs when one transaction reads data that has been written but not yet committed by another transaction. If the changes are latter rolled back, the data obtained by the first transaction will be invalid"]
    },
    {
      "question": "What is a non repeatable read?",
      "answer": ["Happens when a transactions performs the same query two or more times and each time the data is different. This is usually due to another concurrent transaction updating the data between queries"]
    },
    {
      "question": "What is a Phantom read?",
      "answer": ["These occur when a transaction (T1) reads several rows, and then a concurrent transaction (T2) inserts rows. Upon subsequent queries, the first transaction (T1) finds additional rows that weren't there before."]
    },
    {
      "question": "What does REST stand for",
      "answer": [
        "Representational - rest resources can be represented in virtually any form, including xml, json or even html - whatever form best suits the consumer of those resources",
        "State - When working with REST, we're more concerned with the state of a resource than with the actions we can take against resources",
        "Transfer - REST involves transferring resource data, in some representational form, from one application to another"
      ]
    },
    {
      "question": "What does idempotent mean?",
      "answer": ["Methods may or may not change state, but repeatable requests should have not further side effects after the first request. (e.g. GET, PUT, DELETE, OPTIONS)"]
    },
    {
      "question": "REST considered safe if...",
      "answer": ["A method is considered safe if it does not change the state of the resource. GET, OPTIONS"]
    },
    {
      "question": "REST verbs",
      "answer": [
        "GET - Retrieves resource data from the server, The resource is identified by the request's URL.",
        "POST - Posts (creates the resource) data to the server to be handled by a processor listening at the request's URL",
        "PUT - Puts (updates the resource) resource data to the server, at the url of the request",
        "DELETE - Deletes the resource on the server identified by the request's URL",
        "OPTIONS - Requests available options for communication with the server."
      ]
    },
    {
      "question": "Ubiquitous language",
      "answer": ["Building a common; rigorous language between developers and users. The language should be based on the domain model"]
    },
    {
      "question": "What is a monotonic function",
      "answer": [
        "In mathematics a monotonic function (or monotone function) is a function between ordered sets that preserves the given order"
      ]
    },
    {
      "question": "Pure function",
      "answer": [
        "Given the same input it always evaluates to the same output",
        "Does not depend on any hidden information or state (no free variables)",
        "Does not cause any side affect, such as mutation of objects or state, or even IO"
      ]
    },
    {
      "question": "Closures",
      "answer": [
        "A closure is a function that carries an implicit binding to all the variables referenced within it.",
        "In other words, the function (or method) encloses a context around the things it references"
      ]
    },
    {
      "question": "Currying",
      "answer": [
        "Converting a single function of n arguments into n functions with a single argument each.",
        "Given the following: f(X,Y,Z) {Z(X(Y));}",
        "When curried becomes: f(X) { lambda (Y) {lambda (Z){ Z(X(Y));}}",
        "In order to get the full application of f(X,Y,Z), you need todo this. f(X)(Y)(Z);"
      ]
    },
    {
      "question": "Partial function application",
      "answer": [
        "Supplying less arguments to a function that requires more returns a partial function so:",
        "Lets say we have: Add three numbers (a, b, c)",
        "If we supply a, b we get: newMethod = addThreeNumbers(a, b)",
        "So we can: Z = newMethod(c)",
        "Y = newMethod(c2)"
      ]
    },
    {
      "question": "Side effect",
      "answer": [
        "Any observable change of state resulting from an operation whether intentional or not, even a deliberate update"
      ]
    },
    {
      "question": "Homoiconic",
      "answer": [
        "Same representation of code and data, from homo meaning same and icon meaning representation"
      ]
    },
    {
      "question": "Thinking agile",
      "answer": [
        "The greatest of all weaknesses is the fear of appearing weak",
        "Provide options, don't make excuses",
        "Be a catalyst for change",
        "Remember the big picture",
        "Make quality a requirements issue",
        "An investment in knowledge always pays the best interest",
        "Learn at least one new language every year",
        "Isolation can be deadly to your career",
        "Critically analyse what you read and hear"
      ]
    },
    {
      "question": "Geek leaks",
      "answer": [
        "Cross pollination of ideas (not just from software)"
      ]
    },
    {
      "question": "Looked over or overlooked",
      "answer": [
        "It is better to be looked over than overlooked:",
        " - Know what you want to say",
        " - Know your audience",
        " - Choose your moment"
      ]
    },
    {
      "question": "Orthogonality",
      "answer": [
        "Eliminate effects between unrelated things"
      ]
    },
    {
      "question": "Properties of things",
      "answer": [
        "Don't rely on the properties of things you can't control!"
      ]
    },
    {
      "question": "Issue with only one idea...",
      "answer": [
        "Nothing is more dangerous than an idea if its the only one you have"
      ]
    },
    {
      "question": "Final decisions",
      "answer": [
        "There are no final decisions"
      ]
    },
    {
      "question": "Prototype code",
      "answer": [
        "Prototype code is THROW AWAY code"
      ]
    },
    {
      "question": "Assume...",
      "answer": [
        "Don't assume it, prove it"
      ]
    },
    {
      "question": "Requirements metaphor",
      "answer": [
        "Requirements are like water, they're better to build on when they're frozen"
      ]
    },
    {
      "question": "A 'wicked' problem - (Horst Rittel and Melvin Webber",
      "answer": [
        "A problem that can only be clearly defined only by solving it (hidden issues)."
      ]
    },
    {
      "question": "A program should be lean! YAGNI",
      "answer": [
        "You ain't going to need it! Design the system so that it has no extra parts"
      ]
    },
    {
      "question": "Containment",
      "answer": [
        "has a relationship"
      ]
    },
    {
      "question": "Inheritance",
      "answer": [
        "Is a relationship"
      ]
    },
    {
      "question": "When not to add abstractions",
      "answer": [
        "Do not add abstractions that dilute meaning"
      ]
    },
    {
      "question": "When to use inheritance and when to use containment",
      "answer": [
        "If multiple classes share common data but not behaviour, create a common object that those classes can 'containment'",
        "If multiple classes share common behaviour but not data, derive them from a common base class that defines the common routines (inheritance)",
        "If multiple classes share common data and behaviour, inherit from a common base class that defines the common data and routines",
        "Inherit when you want the base class to control your interface: contain when you want to control your interface"
      ]
    },
    {
      "question": "Reasons to create a class",
      "answer": [
        "Model real-world objects",
        "Model abstract objects",
        "Reduce complexity",
        "Isolate complexity",
        "Hide implementation details",
        "Limit effects of change",
        "Hide global data",
        "Stream live parameter passing",
        "Make central points of control"
      ]
    },
    {
      "question": "Fist-class citizen",
      "answer": [
        "An entity that can be constructed at runtime, passed as a parameter, returned from a subroutine, or assigned into a variable"
      ]
    },
    {
      "question": "Mnemonic",
      "answer": [
        "Any learning technique that aids information retention"
      ]
    },
    {
      "question": "Naming, names to avoid:",
      "answer": [
        "Avoid misleading names or abbreviations",
        "Avoid names with similar meanings",
        "Avoid variables with different meanings but similar names",
        "Avoid names that sound the similar e.g wrap, rap",
        "Avoid numerals in names",
        "Avoid multiple natural languages (ubiquitous)"
      ]
    },
    {
      "question": "Issues with global data",
      "answer": [
        "Inadvertent changes to global data - it broke here, here and here!",
        "Bizarre and exciting aliasing problems - calling the variable by two names",
        "Code reuse hindered by global data - Global data might have to be changed inorder to reuse",
        "Modularity and intellectual manageability damaged by global data - The value is always in scope of what you are thinking"
      ]
    },
    {
      "question": "Principle of proximity",
      "answer": [
        "Keep related actions together"
      ]
    },
    {
      "question": "Normal path in code",
      "answer": [
        "Write the normal path through the code first; then write the unusual cases",
        "Put the normal case after the if rather than after the else"
      ]
    },
    {
      "question": "Looping types",
      "answer": [
        "Counted loop - done specific number of times",
        "Continuously evaluated loop - test whether it has finished at each cycle",
        "Endless loop - loop forever... pacemaker?",
        "Iterator loop - loops over all items in a container"
      ]
    },
    {
      "question": "CAP theorem",
      "answer": [
        "In theoretical computer science, the CAP theorem, also known as Brewer's theorem.",
        "States it is impossible, for a distributed computer system, to simultaneously provide all three of the following guarantees",
        " - Consistency (all nodes see the same data at the same time)",
        " - Availability (a guarantee that every request receives a response)",
        " - Partition tolerance (the system continues to operate despite arbitrary partitioning due to network failures)"
      ]
    }
  ]
}